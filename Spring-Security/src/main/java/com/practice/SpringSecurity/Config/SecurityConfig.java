package com.practice.SpringSecurity.Config;

import com.practice.SpringSecurity.Filter.*;
import jakarta.servlet.Filter;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.crypto.scrypt.SCryptPasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.JdbcUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;

import javax.sql.DataSource;
import java.util.Arrays;
import java.util.Collections;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    /**
     * custom security configuration
     */
    @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception{

        CsrfTokenRequestAttributeHandler requestAttributeHandler = new CsrfTokenRequestAttributeHandler();
        requestAttributeHandler.setCsrfRequestAttributeName("_csrf");
        http

                /**
                 * When we will log in through a frontend UI application. Then we can use the below commented configuration.
                 * When we log in through our browser there is a JSESSION_ID generated by our browser.But after implementing frontend application we have to do it by own.
                 * So by this configuration we are telling spring framework that always generate a JSESSION_ID after as successful login and send it to the UI application, so that it can handle the login.
                 */
                /*.securityContext().requireExplicitSave(false)
                .and().sessionManagement(session->session.sessionCreationPolicy(SessionCreationPolicy.ALWAYS))*/

                /**
                 * Configuration for cross-origin-resource-sharing(CORS) access.
                 */
                .cors().configurationSource(new CorsConfigurationSource() {
                    @Override
                    public CorsConfiguration getCorsConfiguration(HttpServletRequest request) {
                        CorsConfiguration config = new CorsConfiguration();
                        config.setAllowedOrigins(Collections.singletonList("http://localhost:9337"));
                        config.setAllowedMethods(Collections.singletonList("*"));
                        config.setAllowCredentials(true);
                        config.setAllowedHeaders(Collections.singletonList("*"));
                        config.setExposedHeaders(Arrays.asList("Authorization"));
                        config.setMaxAge(3600L);
                        return config;
                    }
                }).and()
                /**
                 * Configuration for cross-site-request-forgery(CSRF) access.
                 */
                //By this configuration we are disabling csrf only for the below-mentioned endpoints.
                .csrf((csrf)->csrf.csrfTokenRequestHandler(requestAttributeHandler).ignoringRequestMatchers("/register")
                        //By this configuration we are telling spring framework to generate CSRF token and save in the repository withHttpOnlyFalse(It will allow UI application to read our cookie.)
                        .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()))
                /**
                 * Invoking our own custom filter
                */

                //This custom filter will validate request before the execution of BasicAuthenticationFilter.class
                .addFilterBefore(new RequestValidationBeforeFilter(),BasicAuthenticationFilter.class)
                //This custom filter will print a log at the time of execution of BasicAuthenticationFilter.class
                .addFilterAt(new AuthenticatonAtFilter(),BasicAuthenticationFilter.class)
                //This custom filter will send csrf token after the execution of BasicAuthenticationFilter.class
                .addFilterAfter(new CsrfCookieFilter(),BasicAuthenticationFilter.class)
                //This custom filter will print a log after the execution of BasicAuthenticationFilter.class
                .addFilterAfter(new AuthorityLogAfterFilter(),BasicAuthenticationFilter.class)
                //This custom filter is for testing purpose extending GenericFilterBean
                .addFilterAfter(new GenericFilter(),AuthorityLogAfterFilter.class)
                .addFilterAfter(new JWTTokenGeneratorFilter(), BasicAuthenticationFilter.class)
                .addFilterBefore(new JWTTokenValidatorFilter(), BasicAuthenticationFilter.class)

                /**
                 * The below configuration is for authorizing http requests using request matchers.
                 */
                        .authorizeHttpRequests((request)-> request
//                                .requestMatchers("/myAccount","/myCards","/myLoans","/myBalance").authenticated()
//                                .requestMatchers("/test-account","/test-cards","/test-loans","/test-balance","/account").authenticated()
//                                .requestMatchers("/notices","/contacts","/register").permitAll()
//                                .requestMatchers("/test-notices","/test-contacts","/test-register").permitAll()
//                                .requestMatchers("/log-in").permitAll()
                                        .requestMatchers("/myAccount","/account").hasAuthority("VIEW_ACCOUNT")
                                        .requestMatchers("/myBalance","/balance").hasAuthority("VIEW_BALANCE")
                                        .requestMatchers("/myCards","/cards").hasAuthority("VIEW_CARDS")
                                        .requestMatchers("/myLoans","/loans").hasAuthority("VIEW_LOANS")
                                        .requestMatchers("/test-loans","/test-cards","/test-account","/test-balance")
                                                        .hasAnyAuthority("VIEW_ACCOUNT","VIEW_BALANCE","VIEW_CARDS","VIEW_LOANS")
                                        .requestMatchers("/notices","/contacts","/register").permitAll()
                                        .requestMatchers("/test-notices","/test-contacts","/test-register").permitAll()
                                        .requestMatchers("/log-in").permitAll()
                        )
                .httpBasic(Customizer.withDefaults())
                .formLogin(Customizer.withDefaults());
        return http.build();
    }

    /**
     * The below configuration is for "Form login"
     */

    /*@Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http

                .csrf().disable()
                // ...
                .authorizeHttpRequests((request)-> request
                        //All endpoints are in get mapping but requires request body as mentioned in contrller. Modify it.
                        .requestMatchers("/myAccount","/myCards","/myLoans","/myBalance").authenticated()
                        .requestMatchers("/test-account","/test-cards","/test-loans","/test-balance").authenticated()
                        .requestMatchers("/notices","/contacts","/register").permitAll()
                        .requestMatchers("/test-notices","/test-contacts","/test-register").permitAll()
//                                .anyRequest().permitAll()
        )
                .httpBasic(Customizer.withDefaults())
                .formLogin()
                .loginPage("/login.html")
                .loginProcessingUrl("/perform_login")
                .defaultSuccessUrl("/homepage.html", true)
                .failureUrl("/login.html?error=true")
                .failureHandler(authenticationFailureHandler())
                .and()
                .logout()
                .logoutUrl("/perform_logout")
                .deleteCookies("JSESSIONID")
                .logoutSuccessHandler(logoutSuccessHandler());
        return http.build();
    }*/

    /**
     * Configuration to deny all the requests
     */
 /*   @Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception{
        http
                .csrf().disable()
                .authorizeHttpRequests((request)-> request
                                .anyRequest().denyAll()
                );
        return http.build();
    }*/

    /**
     * Configuration to permit all the requests
     */
    /*@Bean
    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception{
        http
                .csrf().disable()
                .authorizeHttpRequests((request)-> request
                                .anyRequest().permitAll()
                );
        return http.build();
    }*/

    /**
     * Authenticating user using in-memory-database(InMemoryUserDetailsManager)
     */

    /**
     * Approach 1 where we use withDefaultPasswordEncoder() method while creating the user details
     */
/*    @Bean
    public InMemoryUserDetailsManager userDetailsManager(){
        UserDetails admin = User.withDefaultPasswordEncoder()
                .username("admin")
                .password("admin")
                .authorities("read/write")
                .build();

        UserDetails user = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .authorities("read")
                .build();
        return new InMemoryUserDetailsManager(admin,user);
    }*/

    /**
     * Approach 2 where we use NoOpPasswordEncoder bean while creating the user details
     */

    /*@Bean
    public InMemoryUserDetailsManager detailsManager(){
        UserDetails admin = User.withUsername("admin")
                .password("admin")
                .authorities("read/write")
                .build();

        UserDetails user = User.withUsername("user")
                .password("user")
                .authorities("read")
                .build();
        return new InMemoryUserDetailsManager(user,admin);
    }*/

    /**
     * Authenticating user using db(JdbcUserDetailsManager)
     */

    /*@Bean
    public UserDetailsService userDetailsService(DataSource dataSource){
        return new JdbcUserDetailsManager(dataSource);
    }*/

    /**
     * To authenticate with JdbcUserDetailsManager, we need to comply with Spring Security and provide data accordingly, which is not the same as using id,name,password,enabled column in user.
     * We have set up our own custom authentication in the SecurityUserDetails class for authentication.
     */

    /**
     * Spring Security requires a password encoder to be provided.
     * It is mandatory to provide a password encoder to Spring Security.
     */
    /*@Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }*/

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}

